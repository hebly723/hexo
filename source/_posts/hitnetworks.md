---
title: 可靠数据传输
date: 2016-11-07 16:38:23
tags:
 - 计算机网络
categories:
 - 追课
---

 # ARQ（自动重传请求协议）Auto Repeat reQuest

<!-- more --> 

 需要另外三种协议来处理存在的比特差错

 

 ## 差错检测

 

 需要一种机制使接收方检测何时出现了比特差错

 

 ## 接收方反馈

 

发送方要了解接收方情况（即分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息给发送方。口述信息中回答的肯定确认(ACK:positive acknowledge )和否定确认(NAK:negative acknowledge)就是这种反馈的例子。类似地，我们的rdt2.0的协议将从接受方向发送方回送ACK与NAK分组。理论上，这些分组只需要一个比特长度，如用0表示NCK，用1表示ACK。

 

 ## 重传

 

 接收方收到有差错的分组时，发送方将重传该分组

 

 rdt2.0的发送方有两个状态。

 

  - 发送方协议等待上层的数据，当rdt_send(data)事件发生时，发送方将产生一个包含待发送数据的分组(sndpkt)，计算出分组检验(3.3.2)，然后经由udt_send(pkt)操作发送该分组

  - 发送方协议等待接收方的ACK或NAK分组。

  如果收到一个ACK分组，则发送方知道最近传输的分组已被正确接收，因此协议返回到等待上层数据的状态；如果收到一个NAK分组，该协议重传最后一个分组并等待接收方返回的响应重传分组的ACK或NAK。当发送方在wait-for-ACK-or-NAK状态时，它不能从上层获得更多的数据；这就是说，rdt_send()事件不可能出现；仅当接收到ACK并离开该状态时接收方才能获取新数据。因此，发送方不会发送一块新数据，直到发送方确信接收方已正确接收当前分组为止。由于这种行为，类似于rdt2.0的协议被称为停等协议。

  rdt2.0的接收方有一个状态。

  - 当分组到达时，接收方要么回答一个ACK，要么回答一个NAK，取决于收到的分组是否受损
 
 # 缺陷
 
 没有考虑到ACK或者NAK本身受损的可能性,必须检测差错,但更重要的是如果ACK或者NAK分组受损,发送方不知道接收方是否正确接收了上一块发送的数据

 解决办法:

{% blockquote %}
在数据分组中添加一个新字段,让发送方对其数据分组编号,即将发送的数据分组的序号(sequence number)放在该字段.于是,接收方只需检查序号即可确定收到的分组是否是一次重传.
前提:信道不丢失分组
{% endblockquote %}

显然,对于停等协议这种简单情况,1比特序号就足够了,因为它可让接收方知道发送方在重传前一个发送分组(接收到的分组序号与最近收到的分组序号相同),还是一个新分组(序号变化了,用模二运算"前向"移动)
